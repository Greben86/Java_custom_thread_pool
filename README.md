# Курсовая работа. Многопоточное и асинхронное программирование на Java.
## Thread Pool

### Что нужно делать

Представьте, что вы работаете над высоконагруженным (а как же еще) серверным приложением, в котором важно управлять распределением задач (запросов) между потоками. Для обеспечения гибкости и эффективности вы решили не использовать стандартный ThreadPoolExecutor, а написать собственный пул потоков с настраиваемым управлением очередями, логированием, параметрами и политикой отказа.

### Основные требования
#### Параметры настройки пула:

* corePoolSize — минимальное (базовое) количество потоков.
* maxPoolSize — максимальное количество потоков.
* keepAliveTime и timeUnit — время, в течение которого поток может простаивать до завершения и единицы измерения этого самого времени.
* queueSize — ограничение на количество задач в очереди.
* minSpareThreads — минимальное число «резервных» потоков, которые должны быть всегда доступны. Если число свободных потоков падает ниже этого значения, пул должен создавать новые потоки, даже при невысокой нагрузке.

#### Обработка отказов
При переполнении очереди и загруженности всех потоков необходимо реализовать механизм отказа (например, с использованием RejectedExecutionHandler или собственного подхода), который определяет, как поступать с новой задачей (отклонять, выполнять в текущем потоке или применять иной способ обработки). Обязательно укажите, почему выбран именно этот подход и какие могут быть его недостатки.

#### Распределение задач
Также реализуйте алгоритм балансировки задач — например, поступающие задачи могут распределяться по принципу Round Robin между несколькими очередями, привязанными к разным рабочим потокам. При желании можно усложнить задачу и реализовать распределение на основе наименьшей загруженности очереди (Least Loaded), но это необязательно.

#### Кастомизация компонентов
* ThreadFactory — разработайте фабрику для создания потоков, которая будет присваивать потокам уникальные имена и логировать события их создания и завершения.
* Очереди задач — можно использовать несколько стандартных BlockingQueue (по одной на каждый поток) или создать собственную обертку с дополнительной логикой.

#### Worker (рабочий поток) должен:

* Обрабатывать задачи из закрепленной за ним очереди.
При отсутствии задач в течение времени, превышающего keepAliveTime, завершаться, если общее число потоков превышает corePoolSize.
* Перед выполнением новой задачи проверять, что пул не находится в состоянии завершения (shutdown).

#### Логирование
Реализуйте подробное логирование, которое покрывает все ключевые этапы работы системы.

Примеры сообщений (формат вывода можно изменить, главное – содержание) могут быть следующими

````
При создании каждого потока
[ThreadFactory] Creating new thread: MyPool-worker-1
При завершении потока
[Worker] MyPool-worker-1 terminated.
При поступлении задачи
[Pool] Task accepted into queue #(id): <описание задачи>
Если очередь переполнена / задача отклонена
[Rejected] Task <...> was rejected due to overload!
При выполнении каждой задачи
[Worker] MyPool-worker-2 executes <описание задачи>
При idle timeout (воркер не получил задачу за keepAliveTime)
[Worker] MyPool-worker-2 idle timeout, stopping.
Обратите внимание, что вывод логов именно в указанном формате необязателен. Важно, чтобы логи фиксировали все существенные события (создание/завершение потоков, постановка задач в очередь, выполнение задачи, отказ в обработке и таймаут бездействия) и позволяли однозначно понять состояние системы в любой момент.
````

#### Интерфейс управления
Ваш пул потоков должен реализовывать следующий интерфейс:

````
interface CustomExecutor extends Executor {
void execute(Runnable command);
<T> Future<T> submit(Callable<T> callable);
void shutdown();
void shutdownNow();
}
````

Это позволит использовать ваш пул как для работы с CompletableFuture, так и напрямую через методы execute и submit.

#### Демонстрационная программа (вместо Unit-тестов)
Напишите тестовый класс (например, Main), где:

Инициализируется пул с выбранными параметрами (например, corePoolSize=2, maxPoolSize=4, queueSize=5, keepAliveTime=5 секунд).
В пул отправляется несколько «имитационных» задач (например, реализация Runnable, которая делает Thread.sleep(...) и логирует начало и окончание выполнения).
После некоторого времени вызывается метод shutdown() и проверяется, что все задачи завершены, а потоки корректно освобождены.
Демонстрируется обработка ситуации, когда поступает слишком много задач (например, задачи отклоняются или обрабатываются согласно заданной политике).

# Реализация пользовательского пула потоков

## Обзор
Этот проект реализует пользовательский пул потоков с расширенными возможностями для высоконагруженных серверных приложений. Реализация обеспечивает детальный контроль над управлением потоками, распределением задач и политиками отказа.

## Ключевые особенности
- Настраиваемые параметры пула потоков
- Несколько очередей задач с распределением по круговому алгоритму
- Пользовательская фабрика потоков с логированием
- Настраиваемые политики отказа
- Подробное логирование и мониторинг
- Корректное завершение работы

## Анализ производительности

### Сравнение со стандартным ThreadPoolExecutor
Наша пользовательская реализация демонстрирует несколько преимуществ по сравнению со стандартным ThreadPoolExecutor:

1. **Несколько очередей**
    - Уменьшает конкуренцию за одну очередь
    - Лучшая масштабируемость при высокой нагрузке
    - Более предсказуемая производительность

2. **Распределение задач**
    - Круговое распределение обеспечивает лучший баланс нагрузки
    - Уменьшенная конкуренция за очереди
    - Более предсказуемое время выполнения задач

3. **Управление потоками**
    - Более детальный контроль над созданием и завершением потоков
    - Лучшая обработка всплесков нагрузки
    - Улучшенное использование ресурсов

## Оптимальные параметры конфигурации

### Основные параметры
1. **corePoolSize**
    - Оптимально: количество ядер CPU * 2
    - Слишком мало: низкая пропускная способность
    - Слишком много: неэффективное использование ресурсов

2. **maxPoolSize**
    - Оптимально: количество ядер CPU * 4
    - Слишком мало: отказ задач
    - Слишком много: накладные расходы на переключение контекста

3. **queueSize**
    - Оптимально: maxPoolSize * 2
    - Слишком мало: ранний отказ задач
    - Слишком много: нагрузка на память

4. **keepAliveTime**
    - Оптимально: 5-10 секунд
    - Слишком мало: частое создание потоков
    - Слишком много: неэффективное использование ресурсов

### Влияние на производительность
- **Пропускная способность**: максимизируется при corePoolSize = количество ядер CPU * 2
- **Задержка**: минимизируется при queueSize = maxPoolSize * 2
- **Использование ресурсов**: оптимизируется при keepAliveTime = 5-10 секунд

## Механизм распределения задач

### Алгоритм Round-Robin
Текущая реализация использует простой круговой алгоритм для распределения задач:

1. Каждый рабочий поток имеет свою очередь
2. Задачи распределяются последовательно по очередям
3. Счетчик nextQueueIndex отслеживает следующую целевую очередь

### Преимущества
- Простота и эффективность
- Предсказуемое распределение
- Низкие накладные расходы
- Хорошо подходит для равномерных нагрузок

### Возможные улучшения
1. **Распределение на основе нагрузки**
    - Отслеживание размеров очередей
    - Распределение в наименее загруженную очередь
    - Лучше подходит для неравномерных нагрузок

2. **Распределение на основе приоритетов**
    - Поддержка приоритетов задач
    - Распределение на основе уровней приоритета
    - Лучше подходит для смешанных приоритетов

## Примеры использования

### Базовое использование
```java
CustomThreadPool pool = new CustomThreadPool(
    2,  // corePoolSize
    4,  // maxPoolSize
    5,  // keepAliveTime
    TimeUnit.SECONDS,
    5,  // queueSize
    1   // minSpareThreads
);

pool.execute(() -> {
    // Реализация задачи
});

pool.shutdown();
```

### Использование с задачей, возвращающей значение
```java
var pool = new CustomThreadPool(
    2,  // corePoolSize
    4,  // maxPoolSize
    5,  // keepAliveTime
    TimeUnit.SECONDS,
    5,  // queueSize
    1   // minSpareThreads
);

var future = pool.submit(() -> {
    // Реализация задачи
    return "success";
});

pool.shutdown();
```

### Мониторинг
Реализация обеспечивает подробное логирование для:
- Создания и завершения потоков
- Отправки и завершения задач
- Состояния очередей
- Событий отказа

## Рекомендации по использованию

1. **Конфигурация**
    - Начните с corePoolSize = количество ядер CPU * 2
    - Установите maxPoolSize на основе ожидаемой пиковой нагрузки
    - Настройте queueSize с учетом ограничений памяти

2. **Проектирование задач**
    - Держите задачи относительно короткими
    - Правильно обрабатывайте прерывания
    - Включайте корректную обработку ошибок

3. **Мониторинг**
    - Следите за отказами задач
    - Мониторьте паттерны создания потоков
    - Отслеживайте размеры очередей

## Будущие улучшения

1. **Расширенные возможности**
    - Приоритетные очереди
    - Зависимости задач
    - Динамическая конфигурация
    - Сбор метрик

2. **Производительность**
    - Адаптивное создание потоков
    - Распределение на основе нагрузки
    - "Кража" задач из очередей

3. **Мониторинг**
    - Интеграция с JMX
    - Метрики производительности
    - Проверки работоспособности 